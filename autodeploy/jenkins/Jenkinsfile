// AutoDeployX Jenkins Pipeline
// CI/CD: Build ‚Üí Test ‚Üí Push ‚Üí Deploy

pipeline {
    agent any

    environment {
        DOCKER_IMAGE = "sarika/autodeployx"
        BACKEND_URL = "http://backend:8000"
    }

    stages {
        stage('Pipeline Started') {
            steps {
                script {
                    sh """
                        curl -X POST ${BACKEND_URL}/jenkins/status \
                            -H "Content-Type: application/json" \
                            -d '{"status": "running", "pipeline_name": "AutoDeployX", "build_number": ${BUILD_NUMBER}, "stage": "started", "message": "Pipeline #${BUILD_NUMBER} started"}'
                    """
                }
            }
        }

        stage('Checkout') {
            steps {
                checkout scm
                script {
                    sh """
                        curl -X POST ${BACKEND_URL}/deployments/event \
                            -H "Content-Type: application/json" \
                            -d '{"event_type": "checkout", "status": "success", "details": {"branch": "${GIT_BRANCH}"}}'
                    """
                }
            }
        }

        stage('Run Tests') {
            steps {
                dir('app') {
                    sh 'pip install -r requirements.txt'
                    sh 'python -m pytest ../tests/ -v'
                }
                script {
                    sh """
                        curl -X POST ${BACKEND_URL}/deployments/event \
                            -H "Content-Type: application/json" \
                            -d '{"event_type": "test", "status": "success", "details": {"tests_passed": true}}'
                    """
                }
            }
        }

        stage('Build Docker Image') {
            steps {
                dir('docker') {
                    sh "docker build -t ${DOCKER_IMAGE}:${BUILD_NUMBER} -t ${DOCKER_IMAGE}:latest -f Dockerfile .."
                }
                script {
                    sh """
                        curl -X POST ${BACKEND_URL}/deployments/event \
                            -H "Content-Type: application/json" \
                            -d '{"event_type": "build", "status": "success", "details": {"image": "${DOCKER_IMAGE}:${BUILD_NUMBER}"}}'
                    """
                }
            }
        }

        stage('Push to DockerHub') {
            steps {
                withCredentials([usernamePassword(credentialsId: 'dockerhub-creds', usernameVariable: 'DOCKER_USER', passwordVariable: 'DOCKER_PASS')]) {
                    sh 'echo $DOCKER_PASS | docker login -u $DOCKER_USER --password-stdin'
                    sh "docker push ${DOCKER_IMAGE}:${BUILD_NUMBER}"
                    sh "docker push ${DOCKER_IMAGE}:latest"
                }
                script {
                    sh """
                        curl -X POST ${BACKEND_URL}/deployments/event \
                            -H "Content-Type: application/json" \
                            -d '{"event_type": "push", "status": "success", "details": {"registry": "DockerHub", "image": "${DOCKER_IMAGE}:${BUILD_NUMBER}"}}'
                    """
                }
            }
        }

        stage('Deploy to Minikube') {
            steps {
                sh 'kubectl apply -f k8s/deployment.yaml'
                sh 'kubectl apply -f k8s/service.yaml'
                sh 'kubectl rollout status deployment/autodeployx-app --timeout=120s'
                script {
                    sh """
                        curl -X POST ${BACKEND_URL}/deployments/event \
                            -H "Content-Type: application/json" \
                            -d '{"event_type": "deploy", "status": "success", "details": {"cluster": "minikube", "namespace": "default"}}'
                    """
                }
            }
        }
    }

    post {
        success {
            script {
                sh """
                    curl -X POST ${BACKEND_URL}/jenkins/status \
                        -H "Content-Type: application/json" \
                        -d '{"status": "success", "pipeline_name": "AutoDeployX", "build_number": ${BUILD_NUMBER}, "stage": "complete", "message": "Pipeline #${BUILD_NUMBER} completed successfully"}'
                """
            }
        }
        failure {
            script {
                sh """
                    curl -X POST ${BACKEND_URL}/jenkins/status \
                        -H "Content-Type: application/json" \
                        -d '{"status": "failure", "pipeline_name": "AutoDeployX", "build_number": ${BUILD_NUMBER}, "stage": "failed", "message": "Pipeline #${BUILD_NUMBER} failed"}'
                """
            }
        }
    }
}
        
        stage('Push to Docker Hub') {
            steps {
                echo 'üì§ Pushing to Docker Hub...'
                sh """
                    echo \$DOCKERHUB_CREDENTIALS_PSW | docker login -u \$DOCKERHUB_CREDENTIALS_USR --password-stdin
                    docker push ${IMAGE_NAME}:${IMAGE_TAG}
                    docker push ${IMAGE_NAME}:latest
                """
            }
        }
        
        stage('Deploy to Minikube') {
            steps {
                echo '‚ò∏Ô∏è Deploying to Minikube...'
                sh """
                    # Update deployment with new image
                    kubectl set image deployment/autodeployx \
                        autodeployx=${IMAGE_NAME}:${IMAGE_TAG} \
                        -n autodeployx --record
                    
                    # Wait for rollout
                    kubectl rollout status deployment/autodeployx \
                        -n autodeployx --timeout=300s
                    
                    # Verify pods are running
                    kubectl get pods -n autodeployx -l app=autodeployx
                """
            }
        }
        
        stage('Smoke Test') {
            steps {
                echo 'üî• Running smoke tests...'
                sh """
                    # Get service URL
                    SERVICE_URL=\$(minikube service autodeployx-service -n autodeployx --url)
                    
                    # Test health endpoint
                    curl -f \${SERVICE_URL}/health/ || exit 1
                    
                    echo "‚úÖ Smoke tests passed!"
                """
            }
        }
    }
    
    post {
        always {
            echo 'üßπ Cleaning up...'
            sh 'docker logout || true'
            cleanWs()
        }
        success {
            echo 'üéâ Pipeline completed successfully!'
            // Slack notification (if configured)
            // slackSend(color: 'good', message: "Build #${BUILD_NUMBER} succeeded!")
        }
        failure {
            echo '‚ùå Pipeline failed!'
            // slackSend(color: 'danger', message: "Build #${BUILD_NUMBER} failed!")
        }
    }
}
